-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Redundant pure" #-}

module Stella.Check.Trans where

import Prelude
import Stella.Ast.AbsSyntax
import Stella.Check.Types
import Data.Text (Text)
import Data.Foldable
import qualified Stella.Check.Env as Env
import Stella.Check.Env (CheckerM)
import qualified Data.Map as Map
import Control.Monad.Except ( MonadError(throwError) )
import Stella.Check.Errors (mkError, ErrorType (..))
import Control.Monad.IO.Class (liftIO)
import Text.Pretty.Simple (pPrint)
import Data.Functor ((<&>))
import Control.Monad (when)
import Stella.Ast.PrintSyntax (Print)
import Control.Monad.Reader (ask)

type Checker = CheckerM SType

failNotImplemented :: forall a b. (HasPosition a, Print a) => a -> CheckerM b
failNotImplemented node = throwError $ mkError node ErrorUnimplementedCase

failWith :: forall a b. (HasPosition a, Print a) => a -> ErrorType -> CheckerM b
failWith x err = throwError $ mkError x err

debugPrint :: Show a => a ->  CheckerM ()
debugPrint = liftIO . pPrint

debugPrintEnv :: CheckerM ()
debugPrintEnv = do
  env <- ask
  liftIO . pPrint $ env

transProgram :: Program -> Checker
transProgram x = case x of
  AProgram pos languagedecl extensions decls -> do
    env <- transDeclSignatures decls
    Env.withEnv env $
      for_ decls transDecl
    mainFunction <-  case Map.lookup "main" env.termsEnv of
      Just (FuncType ftd) -> pure ftd
      _ -> failWith x ErrorMissingMain
    pure mainFunction.returnType

data TransDeclData = TransDeclData
  { typeAliases :: [(Text, SType)]
  , functions :: [(Text, (FuncTypeData, Decl))]
  }

transDeclSignatures :: [Decl] -> CheckerM Env.Env
transDeclSignatures decls = do
  transData <- transDeclsTypes decls
  pure Env.Env
    { typesEnv = Map.fromList transData.typeAliases
    , termsEnv = Map.fromList $ transData.functions
      <&> \(name, (ftd, _)) -> (name, FuncType ftd)
    }

transDeclsTypes :: [Decl] -> CheckerM TransDeclData
transDeclsTypes = foldlM go start
  where
    go :: TransDeclData -> Decl -> CheckerM TransDeclData
    go cur dec = case dec of
      DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> do
        argsTypes <- fmap snd <$> traverse transParamDecl paramdecls
        returnType <- transReturnType returntype
        let
          func = FuncTypeData
            { argsType = argsTypes
            , returnType = returnType
            }
        pure $ cur{functions = (name, (func, dec)) : cur.functions}
      DeclTypeAlias pos (StellaIdent name) type_ -> do
        t <- transType type_
        pure $ cur{typeAliases = (name, t) : cur.typeAliases}
      _ -> failNotImplemented dec
    start = TransDeclData [] []

transLanguageDecl :: LanguageDecl -> Checker
transLanguageDecl x = case x of
  LanguageCore pos -> failNotImplemented x

transExtension :: Extension -> Checker
transExtension x = case x of
  AnExtension pos extensionnames -> failNotImplemented x

transDecl :: Decl -> Checker
transDecl x = case x of
  DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> do
    env <- transDeclSignatures decls
    paramsTypes <- traverse transParamDecl paramdecls
    retType <- transReturnType returntype
    let envWithParams = Env.addTerms paramsTypes env
    exprT <- Env.withEnv envWithParams $ do
      traverse_ transDecl decls
      transExpr expr
    when (retType /= exprT) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure exprT
  DeclFunGeneric pos annotations (StellaIdent name) stellaidents paramdecls returntype throwtype decl expr -> failNotImplemented x
  DeclTypeAlias pos (StellaIdent name) type_ -> transType type_
  DeclExceptionType pos type_ -> failNotImplemented x
  DeclExceptionVariant pos (StellaIdent name) type_ -> failNotImplemented x

-- looks like dead code
transLocalDecl :: LocalDecl -> Checker
transLocalDecl x = case x of
  ALocalDecl pos decl -> failNotImplemented x

transAnnotation :: Annotation -> Checker
transAnnotation x = case x of
  InlineAnnotation pos -> failNotImplemented x

transParamDecl :: ParamDecl -> CheckerM (Text, SType)
transParamDecl x = case x of
  AParamDecl pos (StellaIdent name) type_ -> (name,) <$> transType type_

transReturnType :: ReturnType -> Checker
transReturnType x = case x of
  NoReturnType pos -> pure $ SimpleType Unit
  SomeReturnType pos type_ -> transType type_

transThrowType :: ThrowType -> Checker
transThrowType x = case x of
  NoThrowType pos -> failNotImplemented x
  SomeThrowType pos types -> failNotImplemented x

transType :: Type -> Checker
transType x = case x of
  TypeFun pos types retType -> do
    argsTypes <- traverse transType types
    returnType <- transType retType
    pure $ FuncType FuncTypeData
      { argsType = argsTypes
      , returnType = returnType
      }
  TypeForAll pos stellaidents type_ -> failNotImplemented x
  TypeRec pos (StellaIdent name) type_ -> failNotImplemented x
  TypeSum pos type_1 type_2 -> failNotImplemented x
  TypeTuple pos types -> failNotImplemented x
  TypeRecord pos recordfieldtypes -> failNotImplemented x
  TypeVariant pos variantfieldtypes -> failNotImplemented x
  TypeList pos type_ -> do
    innerType <- transType type_
    pure $ ListType innerType
  TypeBool pos -> pure $ SimpleType Boolean
  TypeNat  pos-> pure $ SimpleType Nat
  TypeUnit pos -> pure $ SimpleType Unit
  TypeTop pos -> failNotImplemented x
  TypeBottom pos -> failNotImplemented x
  TypeRef pos type_ -> failNotImplemented x
  TypeVar pos (StellaIdent name) -> pure $ TypeVarType name

transMatchCase :: MatchCase -> Checker
transMatchCase x = case x of
  AMatchCase pos pattern_ expr -> failNotImplemented x

transOptionalTyping :: OptionalTyping -> Checker
transOptionalTyping x = case x of
  NoTyping  pos-> failNotImplemented x
  SomeTyping  pos type_ -> failNotImplemented x

transPatternData :: PatternData -> Checker
transPatternData x = case x of
  NoPatternData pos-> failNotImplemented x
  SomePatternData  pos pattern_ -> failNotImplemented x

transExprData :: ExprData -> Checker
transExprData x = case x of
  NoExprData pos -> failNotImplemented x
  SomeExprData  pos expr -> failNotImplemented x

transPattern :: Pattern -> Checker
transPattern x = case x of
  PatternVariant pos (StellaIdent name) patterndata -> failNotImplemented x
  PatternInl pos pattern_ -> failNotImplemented x
  PatternInr pos pattern_ -> failNotImplemented x
  PatternTuple pos patterns -> failNotImplemented x
  PatternRecord pos labelledpatterns -> failNotImplemented x
  PatternList pos patterns -> failNotImplemented x
  PatternCons pos pattern_1 pattern_2 -> failNotImplemented x
  PatternFalse pos -> failNotImplemented x
  PatternTrue pos -> failNotImplemented x
  PatternUnit pos -> failNotImplemented x
  PatternInt pos integer -> failNotImplemented x
  PatternSucc pos pattern_ -> failNotImplemented x
  PatternVar pos (StellaIdent name) -> failNotImplemented x

transLabelledPattern :: LabelledPattern -> Checker
transLabelledPattern x = case x of
  ALabelledPattern pos (StellaIdent name) pattern_ -> failNotImplemented x

transBinding :: Binding -> Checker
transBinding x = case x of
  ABinding pos (StellaIdent name) expr -> failNotImplemented x

transExpr :: Expr -> Checker
transExpr x = case x of
  Sequence pos expr1 expr2 -> do
    expr1Type <- transExpr expr1
    when (expr1Type /= unit_) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    expr2Type <- transExpr expr2
    pure expr2Type
  Assign pos expr1 expr2 -> do
    expr1Type <- transExpr expr1
    expr2Type <- transExpr expr2
    when (expr1Type /= expr2Type) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    pure unit_
  If pos expr1 expr2 expr3 -> do
    expr1Type <- transExpr expr1
    when (expr1Type /= bool_) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    expr2Type <- transExpr expr2
    expr3Type <- transExpr expr3
    when (expr2Type /= expr3Type) $
      failWith expr3 ErrorUnexpectedTypeForExpression
    pure expr2Type
  Let pos patternbindings expr -> failNotImplemented x
  LetRec pos patternbindings expr -> failNotImplemented x
  TypeAbstraction pos stellaidents expr -> failNotImplemented x
  LessThan pos expr1 expr2 -> compareNatsOperator expr1 expr2
  LessThanOrEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  GreaterThan pos expr1 expr2 -> compareNatsOperator expr1 expr2
  GreaterThanOrEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  Equal pos expr1 expr2 -> compareNatsOperator expr1 expr2
  NotEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  TypeAsc pos expr type_ -> failNotImplemented x
  TypeCast pos expr type_ -> failNotImplemented x
  Abstraction pos paramdecls expr -> do
    paramsTypes <- traverse transParamDecl paramdecls
    retType <- Env.withTerms paramsTypes $ transExpr expr
    pure $ FuncType FuncTypeData
      { argsType = snd <$> paramsTypes
      , returnType = retType
      }
  Variant pos (StellaIdent name) exprdata -> failNotImplemented x
  Match pos expr matchcases -> failNotImplemented x
  List pos exprs -> failNotImplemented x
  Add pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  Subtract pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  LogicOr pos expr1 expr2 -> logicOperator expr1 expr2
  Multiply pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  Divide pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  LogicAnd pos expr1 expr2 -> logicOperator expr1 expr2
  Ref pos expr -> failNotImplemented x
  Deref pos expr -> failNotImplemented x
  Application pos func args -> do
    funcType <- transExpr func >>= \case
      FuncType ftd -> pure ftd
      _ -> failWith func ErrorNotAFunction
    (zip args -> argsTypes) <- traverse transExpr args
    checkFunctionApplication x funcType argsTypes
  TypeApplication pos expr types -> failNotImplemented x
  DotRecord pos expr (StellaIdent name) -> failNotImplemented x
  DotTuple pos expr integer -> failNotImplemented x
  Tuple pos exprs -> failNotImplemented x
  Record pos bindings -> failNotImplemented x
  ConsList pos expr1 expr2 -> failNotImplemented x
  Head pos expr -> failNotImplemented x
  IsEmpty pos expr -> failNotImplemented x
  Tail pos expr -> failNotImplemented x
  Panic pos -> failNotImplemented x
  Throw pos expr -> failNotImplemented x
  TryCatch pos expr1 pattern_ expr2 -> failNotImplemented x
  TryWith pos expr1 expr2 -> failNotImplemented x
  Inl pos expr -> failNotImplemented x
  Inr pos expr -> failNotImplemented x
  Succ pos expr -> do
    exprT <- transExpr expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure nat_
  LogicNot pos expr -> failNotImplemented x
  Pred pos expr ->  do
    exprT <- transExpr expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure nat_
  IsZero pos expr -> do
    exprT <- transExpr expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure bool_
  Fix pos expr -> failNotImplemented x
  NatRec pos expr1 expr2 expr3 -> failNotImplemented x
  Fold pos type_ expr -> failNotImplemented x
  Unfold pos type_ expr -> failNotImplemented x
  ConstTrue pos -> pure bool_
  ConstFalse pos -> pure bool_
  ConstUnit pos -> pure unit_
  ConstInt pos integer -> pure nat_
  ConstMemory pos memoryaddress -> failNotImplemented x
  Var pos (StellaIdent name) -> do
    Env.lookupTerm name >>= \case
      Just type_ -> pure type_
      Nothing -> failWith x ErrorUndefinedVariable

transPatternBinding :: PatternBinding -> Checker
transPatternBinding x = case x of
  APatternBinding pos pattern_ expr -> failNotImplemented x

transVariantFieldType :: VariantFieldType -> Checker
transVariantFieldType x = case x of
  AVariantFieldType pos (StellaIdent name) optionaltyping -> failNotImplemented x

transRecordFieldType :: RecordFieldType -> Checker
transRecordFieldType x = case x of
  ARecordFieldType pos (StellaIdent name) type_ -> failNotImplemented x

transTyping :: Typing -> Checker
transTyping x = case x of
  ATyping pos expr type_ -> failNotImplemented x

compareNatsOperator :: Expr -> Expr -> CheckerM SType
compareNatsOperator expr1 expr2 =  do
  expr1Type <- transExpr expr1
  when (expr1Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr expr1
  when (expr2Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure bool_

arithmeticNatsOperator :: Expr -> Expr -> CheckerM SType
arithmeticNatsOperator expr1 expr2 =  do
  expr1Type <- transExpr expr1
  when (expr1Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr expr1
  when (expr2Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure nat_

logicOperator :: Expr -> Expr -> CheckerM SType
logicOperator expr1 expr2 =  do
  expr1Type <- transExpr expr1
  when (expr1Type /= bool_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr expr1
  when (expr2Type /= bool_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure bool_

checkFunctionApplication :: {- Application expr -} Expr -> FuncTypeData -> [(Expr, SType)] -> CheckerM SType
checkFunctionApplication applicationExpr ftd passed = do
    go ftd.argsType passed
    pure ftd.returnType
  where
    go :: {-functions args-} [SType] -> {-passed args-} [(Expr, SType)] -> CheckerM ()
    go (at:ats) ((expr, pa):pas) =
      if (at /= pa)
        then failWith expr ErrorNUnexpectedTypeForAParameter
        else go ats pas
    go [] [] = pure ()
    go _ _ = failWith applicationExpr ErrorNUnexpectedTypeForAParameter
