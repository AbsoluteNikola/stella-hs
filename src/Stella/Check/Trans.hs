-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Stella.Check.Trans where

import Prelude
import Stella.Ast.AbsSyntax
import Stella.Check.Types
import Data.Text (Text)
import Data.Foldable
import qualified Stella.Check.Env as Env
import Stella.Check.Env (CheckerM)
import qualified Data.Map as Map
import Control.Monad.Except ( MonadError(throwError) )

type Checker = CheckerM SType

failure :: forall a b. Show a => a -> CheckerM b
failure x = throwError $ "Undefined case: " ++ show x

transStellaIdent :: StellaIdent -> Checker
transStellaIdent x = case x of
  StellaIdent string -> failure x

transExtensionName :: ExtensionName -> Checker
transExtensionName x = case x of
  ExtensionName string -> failure x

transMemoryAddress :: MemoryAddress -> Checker
transMemoryAddress x = case x of
  MemoryAddress string -> failure x

transProgram :: Program -> Checker
transProgram x = case x of
  AProgram pos languagedecl extensions decls -> do
    env <- transDeclSignatures decls
    mainFunction <-  case Map.lookup "main" env.termsEnv of
      Just (FuncType ftd) -> pure ftd
      _ -> throwError "No main function"
    for_ decls transDecl
    pure mainFunction.returnType

data TransDeclData = TransDeclData
  { typeAliases :: [(Text, SType)]
  , functions :: [(Text, (FuncTypeData, Decl))]
  }

transDeclSignatures :: [Decl] -> CheckerM Env.Env
transDeclSignatures decls = do
  transData <- transDeclsTypes decls
  pure Env.Env
    { typesEnv = Map.fromList transData.typeAliases
    , termsEnv = Map.fromList transData.typeAliases
    }

transDeclsTypes :: [Decl] -> CheckerM TransDeclData
transDeclsTypes = foldlM go start
  where
    go :: TransDeclData -> Decl -> CheckerM TransDeclData
    go cur dec = case dec of
      DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> do
        argsTypes <- fmap snd <$> traverse transParamDecl paramdecls
        returnType <- transReturnType returntype
        let
          func = FuncTypeData
            { argsType = argsTypes
            , returnType = returnType
            }
        pure $ cur{functions = (name, (func, dec)) : cur.functions}
      DeclTypeAlias pos (StellaIdent name) type_ -> do
        t <- transType type_
        pure $ cur{typeAliases = (name, t) : cur.typeAliases}
      _ -> failure dec
    start = TransDeclData [] []

transLanguageDecl :: LanguageDecl -> Checker
transLanguageDecl x = case x of
  LanguageCore pos -> failure x

transExtension :: Extension -> Checker
transExtension x = case x of
  AnExtension pos extensionnames -> failure x

transDecl :: Decl -> Checker
transDecl x = case x of
  DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> failure x
  DeclFunGeneric pos annotations (StellaIdent name) stellaidents paramdecls returntype throwtype decl expr -> failure x
  DeclTypeAlias pos (StellaIdent name) type_ -> failure x
  DeclExceptionType pos type_ -> failure x
  DeclExceptionVariant pos (StellaIdent name) type_ -> failure x

-- looks like dead code
transLocalDecl :: LocalDecl -> Checker
transLocalDecl x = case x of
  ALocalDecl pos decl -> failure x

transAnnotation :: Annotation -> Checker
transAnnotation x = case x of
  InlineAnnotation pos -> failure x

transParamDecl :: ParamDecl -> CheckerM (Text, SType)
transParamDecl x = case x of
  AParamDecl pos (StellaIdent name) type_ -> (name,) <$> transType type_

transReturnType :: ReturnType -> Checker
transReturnType x = case x of
  NoReturnType pos -> pure $ SimpleType Unit
  SomeReturnType pos type_ -> transType type_

transThrowType :: ThrowType -> Checker
transThrowType x = case x of
  NoThrowType pos -> failure x
  SomeThrowType pos types -> failure x

transType :: Type -> Checker
transType x = case x of
  TypeFun pos types retType -> do
    argsTypes <- traverse transType types
    returnType <- transType retType
    pure $ FuncType FuncTypeData
      { argsType = argsTypes
      , returnType = returnType
      }
  TypeForAll pos stellaidents type_ -> failure x
  TypeRec pos (StellaIdent name) type_ -> failure x
  TypeSum pos type_1 type_2 -> failure x
  TypeTuple pos types -> failure x
  TypeRecord pos recordfieldtypes -> failure x
  TypeVariant pos variantfieldtypes -> failure x
  TypeList pos type_ -> do
    innerType <- transType type_
    pure $ ListType innerType
  TypeBool pos -> pure $ SimpleType Boolean
  TypeNat  pos-> pure $ SimpleType Nat
  TypeUnit pos -> pure $ SimpleType Unit
  TypeTop pos -> failure x
  TypeBottom pos -> failure x
  TypeRef pos type_ -> failure x
  TypeVar pos (StellaIdent name) -> pure $ TypeVarType name

transMatchCase :: MatchCase -> Checker
transMatchCase x = case x of
  AMatchCase pos pattern_ expr -> failure x

transOptionalTyping :: OptionalTyping -> Checker
transOptionalTyping x = case x of
  NoTyping  pos-> failure x
  SomeTyping  pos type_ -> failure x

transPatternData :: PatternData -> Checker
transPatternData x = case x of
  NoPatternData pos-> failure x
  SomePatternData  pos pattern_ -> failure x

transExprData :: ExprData -> Checker
transExprData x = case x of
  NoExprData pos -> failure x
  SomeExprData  pos expr -> failure x

transPattern :: Pattern -> Checker
transPattern x = case x of
  PatternVariant pos (StellaIdent name) patterndata -> failure x
  PatternInl pos pattern_ -> failure x
  PatternInr pos pattern_ -> failure x
  PatternTuple pos patterns -> failure x
  PatternRecord pos labelledpatterns -> failure x
  PatternList pos patterns -> failure x
  PatternCons pos pattern_1 pattern_2 -> failure x
  PatternFalse pos -> failure x
  PatternTrue pos -> failure x
  PatternUnit pos -> failure x
  PatternInt pos integer -> failure x
  PatternSucc pos pattern_ -> failure x
  PatternVar pos (StellaIdent name) -> failure x

transLabelledPattern :: LabelledPattern -> Checker
transLabelledPattern x = case x of
  ALabelledPattern pos (StellaIdent name) pattern_ -> failure x

transBinding :: Binding -> Checker
transBinding x = case x of
  ABinding pos (StellaIdent name) expr -> failure x

transExpr :: Expr -> Checker
transExpr x = case x of
  Sequence pos expr1 expr2 -> failure x
  Assign pos expr1 expr2 -> failure x
  If pos expr1 expr2 expr3 -> failure x
  Let pos patternbindings expr -> failure x
  LetRec pos patternbindings expr -> failure x
  TypeAbstraction pos stellaidents expr -> failure x
  LessThan pos expr1 expr2 -> failure x
  LessThanOrEqual pos expr1 expr2 -> failure x
  GreaterThan pos expr1 expr2 -> failure x
  GreaterThanOrEqual pos expr1 expr2 -> failure x
  Equal pos expr1 expr2 -> failure x
  NotEqual pos expr1 expr2 -> failure x
  TypeAsc pos expr type_ -> failure x
  TypeCast pos expr type_ -> failure x
  Abstraction pos paramdecls expr -> failure x
  Variant pos (StellaIdent name) exprdata -> failure x
  Match pos expr matchcases -> failure x
  List pos exprs -> failure x
  Add pos expr1 expr2 -> failure x
  Subtract pos expr1 expr2 -> failure x
  LogicOr pos expr1 expr2 -> failure x
  Multiply pos expr1 expr2 -> failure x
  Divide pos expr1 expr2 -> failure x
  LogicAnd pos expr1 expr2 -> failure x
  Ref pos expr -> failure x
  Deref pos expr -> failure x
  Application pos expr exprs -> failure x
  TypeApplication pos expr types -> failure x
  DotRecord pos expr (StellaIdent name) -> failure x
  DotTuple pos expr integer -> failure x
  Tuple pos exprs -> failure x
  Record pos bindings -> failure x
  ConsList pos expr1 expr2 -> failure x
  Head pos expr -> failure x
  IsEmpty pos expr -> failure x
  Tail pos expr -> failure x
  Panic pos -> failure x
  Throw pos expr -> failure x
  TryCatch pos expr1 pattern_ expr2 -> failure x
  TryWith pos expr1 expr2 -> failure x
  Inl pos expr -> failure x
  Inr pos expr -> failure x
  Succ pos expr -> failure x
  LogicNot pos expr -> failure x
  Pred pos expr -> failure x
  IsZero pos expr -> failure x
  Fix pos expr -> failure x
  NatRec pos expr1 expr2 expr3 -> failure x
  Fold pos type_ expr -> failure x
  Unfold pos type_ expr -> failure x
  ConstTrue pos -> pure $ SimpleType Boolean
  ConstFalse pos -> pure $ SimpleType Boolean
  ConstUnit pos -> pure $ SimpleType Unit
  ConstInt pos integer -> failure x
  ConstMemory pos memoryaddress -> failure x
  Var pos (StellaIdent name) -> failure x

transPatternBinding :: PatternBinding -> Checker
transPatternBinding x = case x of
  APatternBinding pos pattern_ expr -> failure x

transVariantFieldType :: VariantFieldType -> Checker
transVariantFieldType x = case x of
  AVariantFieldType pos (StellaIdent name) optionaltyping -> failure x

transRecordFieldType :: RecordFieldType -> Checker
transRecordFieldType x = case x of
  ARecordFieldType pos (StellaIdent name) type_ -> failure x

transTyping :: Typing -> Checker
transTyping x = case x of
  ATyping pos expr type_ -> failure x
