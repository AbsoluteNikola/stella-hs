-- File generated by the BNF Converter (bnfc 2.9.5).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Redundant pure" #-}

module Stella.Check.Trans where

import Prelude
import Stella.Ast.AbsSyntax
import Stella.Check.Types
import Data.Text (Text)
import Data.Foldable
import qualified Stella.Check.Env as Env
import Stella.Check.Env (CheckerM)
import qualified Data.Map as Map
import Control.Monad.Except ( MonadError(throwError), foldM )
import Stella.Check.Errors (mkError, ErrorType (..))
import Control.Monad.IO.Class (liftIO)
import Text.Pretty.Simple (pPrint)
import Data.Functor ((<&>))
import Control.Monad (when)
import Stella.Ast.PrintSyntax (Print)
import Control.Monad.Reader (ask)
import qualified Data.List as L
import Control.Applicative (liftA2)

type Checker = CheckerM SType

failNotImplemented :: forall a b. (HasPosition a, Print a) => a -> CheckerM b
failNotImplemented node = throwError $ mkError node ErrorUnimplementedCase

failWith :: forall a b. (HasPosition a, Print a) => a -> ErrorType -> CheckerM b
failWith x err = throwError $ mkError x err

debugPrint :: Show a => a ->  CheckerM ()
debugPrint = liftIO . pPrint

debugPrintEnv :: CheckerM ()
debugPrintEnv = do
  env <- ask
  liftIO . pPrint $ env

transProgram :: Program -> Checker
transProgram x = case x of
  AProgram pos languagedecl extensions decls -> do
    env <- transDeclSignatures decls
    Env.withEnv env $
      for_ decls transDecl
    mainFunction <-  case Map.lookup "main" env.termsEnv of
      Just (FuncType ftd) -> pure ftd
      _ -> failWith x ErrorMissingMain
    pure mainFunction.returnType

data TransDeclData = TransDeclData
  { typeAliases :: [(Text, SType)]
  , functions :: [(Text, (FuncTypeData, Decl))]
  }

transDeclSignatures :: [Decl] -> CheckerM Env.Env
transDeclSignatures decls = do
  transData <- transDeclsTypes decls
  pure Env.Env
    { typesEnv = Map.fromList transData.typeAliases
    , termsEnv = Map.fromList $ transData.functions
      <&> \(name, (ftd, _)) -> (name, FuncType ftd)
    }

transDeclsTypes :: [Decl] -> CheckerM TransDeclData
transDeclsTypes = foldlM go start
  where
    go :: TransDeclData -> Decl -> CheckerM TransDeclData
    go cur dec = case dec of
      DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> do
        argsTypes <- fmap snd <$> traverse transParamDecl paramdecls
        returnType <- transReturnType returntype
        let
          func = FuncTypeData
            { argsType = argsTypes
            , returnType = returnType
            }
        pure $ cur{functions = (name, (func, dec)) : cur.functions}
      DeclTypeAlias pos (StellaIdent name) type_ -> do
        t <- transType type_
        pure $ cur{typeAliases = (name, t) : cur.typeAliases}
      _ -> failNotImplemented dec
    start = TransDeclData [] []

transLanguageDecl :: LanguageDecl -> Checker
transLanguageDecl x = case x of
  LanguageCore pos -> failNotImplemented x

transExtension :: Extension -> Checker
transExtension x = case x of
  AnExtension pos extensionnames -> failNotImplemented x

transDecl :: Decl -> Checker
transDecl x = case x of
  DeclFun pos annotations (StellaIdent name) paramdecls returntype throwtype decls expr -> do
    env <- transDeclSignatures decls
    paramsTypes <- traverse transParamDecl paramdecls
    retType <- transReturnType returntype
    let envWithParams = Env.addTerms paramsTypes env
    exprT <- Env.withEnv envWithParams $ do
      traverse_ transDecl decls
      transExpr (Just retType) expr
    when (retType /= exprT) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure exprT
  DeclFunGeneric pos annotations (StellaIdent name) stellaidents paramdecls returntype throwtype decl expr -> failNotImplemented x
  DeclTypeAlias pos (StellaIdent name) type_ -> transType type_
  DeclExceptionType pos type_ -> failNotImplemented x
  DeclExceptionVariant pos (StellaIdent name) type_ -> failNotImplemented x

-- looks like dead code
transLocalDecl :: LocalDecl -> Checker
transLocalDecl x = case x of
  ALocalDecl pos decl -> failNotImplemented x

transAnnotation :: Annotation -> Checker
transAnnotation x = case x of
  InlineAnnotation pos -> failNotImplemented x

transParamDecl :: ParamDecl -> CheckerM (Text, SType)
transParamDecl x = case x of
  AParamDecl pos (StellaIdent name) type_ -> (name,) <$> transType type_

transReturnType :: ReturnType -> Checker
transReturnType x = case x of
  NoReturnType pos -> pure $ SimpleType Unit
  SomeReturnType pos type_ -> transType type_

transThrowType :: ThrowType -> Checker
transThrowType x = case x of
  NoThrowType pos -> failNotImplemented x
  SomeThrowType pos types -> failNotImplemented x

transType :: Type -> Checker
transType x = case x of
  TypeFun pos types retType -> do
    argsTypes <- traverse transType types
    returnType <- transType retType
    pure $ FuncType FuncTypeData
      { argsType = argsTypes
      , returnType = returnType
      }
  TypeForAll pos stellaidents type_ -> failNotImplemented x
  TypeRec pos (StellaIdent name) type_ -> failNotImplemented x
  TypeSum pos type_1 type_2 -> do
    t1 <- transType type_1
    t2 <- transType type_2
    pure $ SumType SumTypeData
      { leftType = t1
      , rightType = t2
      }
  TypeTuple pos types' -> do
    types <- traverse transType types'
    pure $ TupleType TupleTypeData
      { tupleTypes = types
      }
  TypeRecord pos recordfieldtypes -> do
    recordFields <- traverse transRecordFieldType recordfieldtypes
    checkThatNamesUniq x $ fst <$> recordFields
    pure $ RecordType RecordTypeData
      { recordFields = Map.fromList recordFields
      }
  TypeVariant pos variantfieldtypes -> do
    variantFields <- traverse transVariantFieldType variantfieldtypes
    checkThatNamesUniq x $ fst <$> variantFields
    pure $ VariantType VariantTypeData
      { variants = Map.fromList variantFields
      }
  TypeList pos type_ -> do
    innerType <- transType type_
    pure $ ListType innerType
  TypeBool pos -> pure $ SimpleType Boolean
  TypeNat  pos-> pure $ SimpleType Nat
  TypeUnit pos -> pure $ SimpleType Unit
  TypeTop pos -> failNotImplemented x
  TypeBottom pos -> failNotImplemented x
  TypeRef pos type_ -> failNotImplemented x
  TypeVar pos (StellaIdent name) -> pure $ TypeVarType name

transMatchCase :: MatchCase -> Checker
transMatchCase x = case x of
  AMatchCase pos pattern_ expr -> failNotImplemented x

transOptionalTyping :: OptionalTyping -> Checker
transOptionalTyping x = case x of
  NoTyping  pos-> failNotImplemented x
  SomeTyping  pos type_ -> failNotImplemented x

transPatternData :: PatternData -> Checker
transPatternData x = case x of
  NoPatternData pos-> failNotImplemented x
  SomePatternData pos pattern_ -> failNotImplemented x

transExprData :: ExprData -> Checker
transExprData x = case x of
  NoExprData pos -> failNotImplemented x
  SomeExprData  pos expr -> failNotImplemented x

transPattern :: SType -> Pattern -> CheckerM [(Text, SType)]
transPattern t x = case x of
  PatternVariant pos (StellaIdent name) patterndata -> failNotImplemented x
  PatternInl pos pattern_ -> failNotImplemented x
  PatternInr pos pattern_ -> failNotImplemented x
  PatternTuple pos patterns -> failNotImplemented x
  PatternRecord pos labelledpatterns -> failNotImplemented x
  PatternList pos patterns -> failNotImplemented x
  PatternCons pos pattern_1 pattern_2 -> failNotImplemented x
  PatternFalse pos -> failNotImplemented x
  PatternTrue pos -> failNotImplemented x
  PatternUnit pos -> failNotImplemented x
  PatternInt pos integer -> failNotImplemented x
  PatternSucc pos pattern_ -> failNotImplemented x
  PatternVar pos (StellaIdent name) -> pure [(name, t)]
  PatternAsc _ _ _ -> failNotImplemented x

transLabelledPattern :: LabelledPattern -> Checker
transLabelledPattern x = case x of
  ALabelledPattern pos (StellaIdent name) pattern_ -> failNotImplemented x

transBinding :: Binding -> CheckerM (Text, SType)
transBinding x = case x of
  ABinding pos (StellaIdent name) expr -> do
    type_ <- transExpr Nothing expr
    pure (name, type_)

transExpr :: Maybe SType -> Expr -> Checker
transExpr desiredType x = case x of
  Sequence pos expr1 expr2 -> do
    expr1Type <- transExpr (Just unit_) expr1
    when (expr1Type /= unit_) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    expr2Type <- transExpr desiredType expr2
    pure expr2Type
  Assign pos expr1 expr2 -> do
    expr1Type <- transExpr Nothing expr1
    expr2Type <- transExpr (Just expr1Type) expr2
    when (expr1Type /= expr2Type) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    pure unit_
  If pos expr1 expr2 expr3 -> do
    expr1Type <- transExpr (Just bool_) expr1
    when (expr1Type /= bool_) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    expr2Type <- transExpr desiredType expr2
    expr3Type <- transExpr (Just expr2Type) expr3
    when (expr2Type /= expr3Type) $
      failWith expr3 ErrorUnexpectedTypeForExpression
    pure expr2Type
  Let pos patternbindings expr -> do
    let
      travBindings :: [(Text, SType)] -> PatternBinding -> CheckerM [(Text, SType)]
      travBindings newVars binding = Env.withTerms newVars $ do
        newVarsFromPattern <- transPatternBinding binding
        pure $ newVars ++ newVarsFromPattern
    newVars <- foldM travBindings [] patternbindings
    exprT <- Env.withTerms newVars $ do
      transExpr desiredType expr
    pure exprT
  LetRec pos patternbindings expr -> failNotImplemented x
  TypeAbstraction pos stellaidents expr -> failNotImplemented x
  LessThan pos expr1 expr2 -> compareNatsOperator expr1 expr2
  LessThanOrEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  GreaterThan pos expr1 expr2 -> compareNatsOperator expr1 expr2
  GreaterThanOrEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  Equal pos expr1 expr2 -> compareNatsOperator expr1 expr2
  NotEqual pos expr1 expr2 -> compareNatsOperator expr1 expr2
  TypeAsc pos expr type_ -> do
    t <- transType type_
    exprT <- transExpr (Just t) expr
    when (exprT /= t) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure exprT
  TypeCast pos expr type_ -> failNotImplemented x
  Abstraction pos paramdecls expr -> do
    paramsTypes <- traverse transParamDecl paramdecls
    -- with some manipulations we can understand desired type
    retType <- Env.withTerms paramsTypes $ transExpr Nothing expr
    pure $ FuncType FuncTypeData
      { argsType = snd <$> paramsTypes
      , returnType = retType
      }
  Variant pos (StellaIdent name) exprdata -> failNotImplemented x
  Match pos expr matchcases -> failNotImplemented x
  List pos exprs -> do
    case exprs of
      -- empty list, should infer type
      [] -> case desiredType of
        Just (ListType t) -> pure (ListType t)
        Just _ -> failWith x ErrorUnexpectedTypeForExpression
        Nothing -> failWith x ErrorAmbiguousList
      (e:es) -> do
        -- with some manipulations we can understand desired type
        eT <- transExpr Nothing e
        for_ es $ \e' -> do
          e'T <- transExpr Nothing e'
          when (e'T /= eT) $
            failWith e' ErrorUnexpectedTypeForExpression
        pure $ ListType eT
  Add pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  Subtract pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  LogicOr pos expr1 expr2 -> logicOperator expr1 expr2
  Multiply pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  Divide pos expr1 expr2 -> arithmeticNatsOperator expr1 expr2
  LogicAnd pos expr1 expr2 -> logicOperator expr1 expr2
  Ref pos expr -> failNotImplemented x
  Deref pos expr -> failNotImplemented x
  Application pos func args -> do
    funcType <- transExpr Nothing func >>= \case
      FuncType ftd -> pure ftd
      _ -> failWith func ErrorNotAFunction
    (zip args -> argsTypes) <- traverse (transExpr Nothing) args
    checkFunctionApplication x funcType argsTypes
  TypeApplication pos expr types -> failNotImplemented x
  DotRecord pos expr (StellaIdent name) -> do
    rtd <- transExpr Nothing expr >>= \case
      RecordType (RecordTypeData rtd) -> pure rtd
      _ -> failWith expr ErrorNotARecord
    case Map.lookup name rtd of
      Just t -> pure t
      Nothing -> failWith expr (ErrorMissingRecordFields name)
  DotTuple pos expr index -> do
    ttd <- transExpr Nothing expr >>= \case
      TupleType (TupleTypeData ttd) -> pure ttd
      _ -> failWith expr ErrorNotATuple
    case ttd !!? (index - 1) of
      Just t -> pure t
      Nothing -> failWith expr (ErrorTupleIndexOutOfBounds index)
  Tuple pos exprs -> do
    types <- traverse (transExpr Nothing) exprs
    pure $ TupleType TupleTypeData
      { tupleTypes = types
      }
  Record pos bindings_ -> do
    bindings <- traverse transBinding bindings_
    checkThatNamesUniq x $ fst <$> bindings
    pure $ RecordType RecordTypeData
      { recordFields = Map.fromList bindings
      }
  ConsList pos expr1 expr2 -> do
    listInnerType <- transExpr Nothing expr2 >>= \case
      ListType listInnerType -> pure listInnerType
      _ -> failWith expr2 ErrorUnexpectedList
    expr1T <- transExpr (Just listInnerType) expr1
    when (expr1T /= listInnerType) $
      failWith expr1 ErrorUnexpectedTypeForExpression
    pure $ ListType listInnerType
  Head pos expr -> do
    listInnerType <- transExpr Nothing expr >>= \case
      ListType listInnerType -> pure listInnerType
      _ -> failWith expr ErrorUnexpectedList
    pure listInnerType
  IsEmpty pos expr -> do
    transExpr Nothing expr >>= \case
      ListType _ -> pure ()
      _ -> failWith expr ErrorUnexpectedList
    pure bool_
  Tail pos expr -> do
    listType <- transExpr Nothing expr >>= \case
      lt@(ListType _) -> pure lt
      _ -> failWith expr ErrorUnexpectedList
    pure listType
  Panic pos -> failNotImplemented x
  Throw pos expr -> failNotImplemented x
  TryCatch pos expr1 pattern_ expr2 -> failNotImplemented x
  TryWith pos expr1 expr2 -> failNotImplemented x
  Inl pos expr -> failNotImplemented x
  Inr pos expr -> failNotImplemented x
  Succ pos expr -> do
    exprT <- transExpr (Just nat_) expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure nat_
  LogicNot pos expr -> failNotImplemented x
  Pred pos expr ->  do
    exprT <- transExpr (Just nat_) expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure nat_
  IsZero pos expr -> do
    exprT <- transExpr (Just nat_) expr
    when (exprT /= nat_) $
      failWith expr ErrorUnexpectedTypeForExpression
    pure bool_
  Fix pos expr -> failNotImplemented x
  NatRec pos expr1 expr2 expr3 -> failNotImplemented x
  Fold pos type_ expr -> failNotImplemented x
  Unfold pos type_ expr -> failNotImplemented x
  ConstTrue pos -> pure bool_
  ConstFalse pos -> pure bool_
  ConstUnit pos -> pure unit_
  ConstInt pos integer -> pure nat_
  ConstMemory pos memoryaddress -> failNotImplemented x
  Var pos (StellaIdent name) -> lookupTermThrow x name

transPatternBinding :: PatternBinding -> CheckerM [(Text, SType)]
transPatternBinding x = case x of
  APatternBinding pos pattern_ expr -> do
    exprT <- transExpr Nothing expr
    newTerms <- transPattern exprT pattern_
    pure newTerms

transVariantFieldType :: VariantFieldType -> CheckerM (Text, VariantCaseType)
transVariantFieldType x = case x of
  AVariantFieldType pos (StellaIdent name) (SomeTyping typingPos type_) -> do
    t <- transType type_
    pure (name, VariantCaseWithType t)
  AVariantFieldType pos (StellaIdent name) (NoTyping typingPos) -> do
    pure (name, VariantCaseWithoutType)

transRecordFieldType :: RecordFieldType -> CheckerM (Text, SType)
transRecordFieldType x = case x of
  ARecordFieldType pos (StellaIdent name) type_ -> do
    t <- transType type_
    pure (name, t)

transTyping :: Typing -> Checker
transTyping x = case x of
  ATyping pos expr type_ -> failNotImplemented x

compareNatsOperator :: Expr -> Expr -> CheckerM SType
compareNatsOperator expr1 expr2 =  do
  expr1Type <- transExpr (Just nat_) expr1
  when (expr1Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr (Just nat_) expr1
  when (expr2Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure bool_

arithmeticNatsOperator :: Expr -> Expr -> CheckerM SType
arithmeticNatsOperator expr1 expr2 =  do
  expr1Type <- transExpr (Just nat_) expr1
  when (expr1Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr (Just nat_) expr1
  when (expr2Type /= nat_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure nat_

logicOperator :: Expr -> Expr -> CheckerM SType
logicOperator expr1 expr2 =  do
  expr1Type <- transExpr (Just bool_) expr1
  when (expr1Type /= bool_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  expr2Type <- transExpr (Just bool_) expr1
  when (expr2Type /= bool_) $
    failWith expr1 ErrorUnexpectedTypeForExpression
  pure bool_

checkFunctionApplication :: {- Application expr -} Expr -> FuncTypeData -> [(Expr, SType)] -> CheckerM SType
checkFunctionApplication applicationExpr ftd passed = do
    go ftd.argsType passed
    pure ftd.returnType
  where
    go :: {-functions args-} [SType] -> {-passed args-} [(Expr, SType)] -> CheckerM ()
    go (at:ats) ((expr, pa):pas) =
      if at /= pa
        then failWith expr ErrorUnexpectedTypeForAParameter
        else go ats pas
    go [] [] = pure ()
    go _ _ = failWith applicationExpr ErrorUnexpectedTypeForAParameter

checkThatNamesUniq :: (HasPosition node, Print node) => node -> [Text] -> CheckerM ()
checkThatNamesUniq expr names = case filter ((> 1) . snd) counts of
    [] -> pure ()
    (fmap fst -> nonUniqNames) -> failWith expr (ErrorDuplicateRecordFields nonUniqNames)
  where
    counts = map (liftA2 (,) head length) . L.group . L.sort $ names

lookupTermThrow :: (HasPosition node, Print node) => node -> Text -> CheckerM SType
lookupTermThrow node name = Env.lookupTerm name >>= \case
  Just type_ -> pure type_
  Nothing -> failWith node ErrorUndefinedVariable

-- Thanks relude :)
infix 9 !!?
(!!?) :: [a] -> Integer -> Maybe a
(!!?) xs i
    | i < 0     = Nothing
    | otherwise = go i xs
  where
    go :: Integer -> [a] -> Maybe a
    go 0 (x:_)  = Just x
    go j (_:ys) = go (j - 1) ys
    go _ []     = Nothing
{-# INLINE (!!?) #-}
