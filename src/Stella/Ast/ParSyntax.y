-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Stella.Ast.ParSyntax
  ( happyError
  , myLexer
  , pProgram
  , pListStellaIdent
  , pLanguageDecl
  , pExtension
  , pListExtensionName
  , pListExtension
  , pDecl
  , pListDecl
  , pLocalDecl
  , pListLocalDecl
  , pAnnotation
  , pListAnnotation
  , pParamDecl
  , pListParamDecl
  , pReturnType
  , pThrowType
  , pType9
  , pListType9
  , pMatchCase
  , pListMatchCase
  , pOptionalTyping
  , pPatternData
  , pExprData
  , pPattern
  , pListPattern
  , pLabelledPattern
  , pListLabelledPattern
  , pBinding
  , pListBinding
  , pExpr
  , pListExpr
  , pExpr1
  , pPatternBinding
  , pListPatternBinding
  , pExpr2
  , pListExpr2
  , pExpr3
  , pExpr4
  , pExpr5
  , pExpr6
  , pExpr7
  , pType
  , pType1
  , pType2
  , pType3
  , pListType
  , pVariantFieldType
  , pListVariantFieldType
  , pRecordFieldType
  , pListRecordFieldType
  , pTyping
  ) where

import Prelude

import qualified Stella.Ast.AbsSyntax
import Stella.Ast.LexSyntax
import qualified Data.Text

}

%name pProgram_internal Program
%name pListStellaIdent_internal ListStellaIdent
%name pLanguageDecl_internal LanguageDecl
%name pExtension_internal Extension
%name pListExtensionName_internal ListExtensionName
%name pListExtension_internal ListExtension
%name pDecl_internal Decl
%name pListDecl_internal ListDecl
%name pLocalDecl_internal LocalDecl
%name pListLocalDecl_internal ListLocalDecl
%name pAnnotation_internal Annotation
%name pListAnnotation_internal ListAnnotation
%name pParamDecl_internal ParamDecl
%name pListParamDecl_internal ListParamDecl
%name pReturnType_internal ReturnType
%name pThrowType_internal ThrowType
%name pType9_internal Type9
%name pListType9_internal ListType9
%name pMatchCase_internal MatchCase
%name pListMatchCase_internal ListMatchCase
%name pOptionalTyping_internal OptionalTyping
%name pPatternData_internal PatternData
%name pExprData_internal ExprData
%name pPattern_internal Pattern
%name pListPattern_internal ListPattern
%name pLabelledPattern_internal LabelledPattern
%name pListLabelledPattern_internal ListLabelledPattern
%name pBinding_internal Binding
%name pListBinding_internal ListBinding
%name pExpr_internal Expr
%name pListExpr_internal ListExpr
%name pExpr1_internal Expr1
%name pPatternBinding_internal PatternBinding
%name pListPatternBinding_internal ListPatternBinding
%name pExpr2_internal Expr2
%name pListExpr2_internal ListExpr2
%name pExpr3_internal Expr3
%name pExpr4_internal Expr4
%name pExpr5_internal Expr5
%name pExpr6_internal Expr6
%name pExpr7_internal Expr7
%name pType_internal Type
%name pType1_internal Type1
%name pType2_internal Type2
%name pType3_internal Type3
%name pListType_internal ListType
%name pVariantFieldType_internal VariantFieldType
%name pListVariantFieldType_internal ListVariantFieldType
%name pRecordFieldType_internal RecordFieldType
%name pListRecordFieldType_internal ListRecordFieldType
%name pTyping_internal Typing
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='            { PT _ (TS _ 1)            }
  '&'             { PT _ (TS _ 2)            }
  '('             { PT _ (TS _ 3)            }
  ')'             { PT _ (TS _ 4)            }
  '*'             { PT _ (TS _ 5)            }
  '+'             { PT _ (TS _ 6)            }
  ','             { PT _ (TS _ 7)            }
  '-'             { PT _ (TS _ 8)            }
  '->'            { PT _ (TS _ 9)            }
  '.'             { PT _ (TS _ 10)           }
  '/'             { PT _ (TS _ 11)           }
  ':'             { PT _ (TS _ 12)           }
  ':='            { PT _ (TS _ 13)           }
  ';'             { PT _ (TS _ 14)           }
  '<'             { PT _ (TS _ 15)           }
  '<='            { PT _ (TS _ 16)           }
  '<|'            { PT _ (TS _ 17)           }
  '='             { PT _ (TS _ 18)           }
  '=='            { PT _ (TS _ 19)           }
  '=>'            { PT _ (TS _ 20)           }
  '>'             { PT _ (TS _ 21)           }
  '>='            { PT _ (TS _ 22)           }
  'Bool'          { PT _ (TS _ 23)           }
  'Bot'           { PT _ (TS _ 24)           }
  'List::head'    { PT _ (TS _ 25)           }
  'List::isempty' { PT _ (TS _ 26)           }
  'List::tail'    { PT _ (TS _ 27)           }
  'Nat'           { PT _ (TS _ 28)           }
  'Nat::iszero'   { PT _ (TS _ 29)           }
  'Nat::pred'     { PT _ (TS _ 30)           }
  'Nat::rec'      { PT _ (TS _ 31)           }
  'Top'           { PT _ (TS _ 32)           }
  'Unit'          { PT _ (TS _ 33)           }
  '['             { PT _ (TS _ 34)           }
  ']'             { PT _ (TS _ 35)           }
  'and'           { PT _ (TS _ 36)           }
  'as'            { PT _ (TS _ 37)           }
  'cast'          { PT _ (TS _ 38)           }
  'catch'         { PT _ (TS _ 39)           }
  'cons'          { PT _ (TS _ 40)           }
  'core'          { PT _ (TS _ 41)           }
  'else'          { PT _ (TS _ 42)           }
  'exception'     { PT _ (TS _ 43)           }
  'extend'        { PT _ (TS _ 44)           }
  'false'         { PT _ (TS _ 45)           }
  'fix'           { PT _ (TS _ 46)           }
  'fn'            { PT _ (TS _ 47)           }
  'fold'          { PT _ (TS _ 48)           }
  'forall'        { PT _ (TS _ 49)           }
  'generic'       { PT _ (TS _ 50)           }
  'if'            { PT _ (TS _ 51)           }
  'in'            { PT _ (TS _ 52)           }
  'inl'           { PT _ (TS _ 53)           }
  'inline'        { PT _ (TS _ 54)           }
  'inr'           { PT _ (TS _ 55)           }
  'language'      { PT _ (TS _ 56)           }
  'let'           { PT _ (TS _ 57)           }
  'letrec'        { PT _ (TS _ 58)           }
  'match'         { PT _ (TS _ 59)           }
  'new'           { PT _ (TS _ 60)           }
  'not'           { PT _ (TS _ 61)           }
  'or'            { PT _ (TS _ 62)           }
  'panic!'        { PT _ (TS _ 63)           }
  'return'        { PT _ (TS _ 64)           }
  'succ'          { PT _ (TS _ 65)           }
  'then'          { PT _ (TS _ 66)           }
  'throw'         { PT _ (TS _ 67)           }
  'throws'        { PT _ (TS _ 68)           }
  'true'          { PT _ (TS _ 69)           }
  'try'           { PT _ (TS _ 70)           }
  'type'          { PT _ (TS _ 71)           }
  'unfold'        { PT _ (TS _ 72)           }
  'unit'          { PT _ (TS _ 73)           }
  'variant'       { PT _ (TS _ 74)           }
  'with'          { PT _ (TS _ 75)           }
  '{'             { PT _ (TS _ 76)           }
  '|'             { PT _ (TS _ 77)           }
  '|>'            { PT _ (TS _ 78)           }
  '}'             { PT _ (TS _ 79)           }
  'µ'             { PT _ (TS _ 80)           }
  L_integ         { PT _ (TI _)              }
  L_StellaIdent   { PT _ (T_StellaIdent _)   }
  L_ExtensionName { PT _ (T_ExtensionName _) }
  L_MemoryAddress { PT _ (T_MemoryAddress _) }

%%

Integer :: { (Stella.Ast.AbsSyntax.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), (read (Data.Text.unpack (tokenText $1))) :: Integer) }

StellaIdent :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.StellaIdent) }
StellaIdent  : L_StellaIdent { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.StellaIdent (tokenText $1)) }

ExtensionName :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.ExtensionName) }
ExtensionName  : L_ExtensionName { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.ExtensionName (tokenText $1)) }

MemoryAddress :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.MemoryAddress) }
MemoryAddress  : L_MemoryAddress { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.MemoryAddress (tokenText $1)) }

Program :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Program) }
Program
  : LanguageDecl ListExtension ListDecl { (fst $1, Stella.Ast.AbsSyntax.AProgram (fst $1) (snd $1) (snd $2) (snd $3)) }

ListStellaIdent :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.StellaIdent]) }
ListStellaIdent
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | StellaIdent { (fst $1, (:[]) (snd $1)) }
  | StellaIdent ',' ListStellaIdent { (fst $1, (:) (snd $1) (snd $3)) }

LanguageDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.LanguageDecl) }
LanguageDecl
  : 'language' 'core' ';' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.LanguageCore (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }

Extension :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Extension) }
Extension
  : 'extend' 'with' ListExtensionName { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.AnExtension (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }

ListExtensionName :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.ExtensionName]) }
ListExtensionName
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | ExtensionName { (fst $1, (:[]) (snd $1)) }
  | ExtensionName ',' ListExtensionName { (fst $1, (:) (snd $1) (snd $3)) }

ListExtension :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Extension]) }
ListExtension
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Extension ';' ListExtension { (fst $1, (:) (snd $1) (snd $3)) }

Decl :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Decl) }
Decl
  : ListAnnotation 'fn' StellaIdent '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { (fst $1, Stella.Ast.AbsSyntax.DeclFun (fst $1) (snd $1) (snd $3) (snd $5) (snd $7) (snd $8) (snd $10) (snd $12)) }
  | ListAnnotation 'generic' 'fn' StellaIdent '[' ListStellaIdent ']' '(' ListParamDecl ')' ReturnType ThrowType '{' ListDecl 'return' Expr '}' { (fst $1, Stella.Ast.AbsSyntax.DeclFunGeneric (fst $1) (snd $1) (snd $4) (snd $6) (snd $9) (snd $11) (snd $12) (snd $14) (snd $16)) }
  | 'type' StellaIdent '=' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.DeclTypeAlias (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'exception' 'type' '=' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.DeclExceptionType (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $4)) }
  | 'exception' 'variant' StellaIdent ':' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.DeclExceptionVariant (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }

ListDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Decl]) }
ListDecl
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Decl ListDecl { (fst $1, (:) (snd $1) (snd $2)) }

LocalDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.LocalDecl) }
LocalDecl
  : Decl { (fst $1, Stella.Ast.AbsSyntax.ALocalDecl (fst $1) (snd $1)) }

ListLocalDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.LocalDecl]) }
ListLocalDecl
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | LocalDecl ';' ListLocalDecl { (fst $1, (:) (snd $1) (snd $3)) }

Annotation :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Annotation) }
Annotation
  : 'inline' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.InlineAnnotation (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }

ListAnnotation :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Annotation]) }
ListAnnotation
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Annotation ListAnnotation { (fst $1, (:) (snd $1) (snd $2)) }

ParamDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.ParamDecl) }
ParamDecl
  : StellaIdent ':' Type { (fst $1, Stella.Ast.AbsSyntax.AParamDecl (fst $1) (snd $1) (snd $3)) }

ListParamDecl :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.ParamDecl]) }
ListParamDecl
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | ParamDecl { (fst $1, (:[]) (snd $1)) }
  | ParamDecl ',' ListParamDecl { (fst $1, (:) (snd $1) (snd $3)) }

ReturnType :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.ReturnType) }
ReturnType
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, Stella.Ast.AbsSyntax.NoReturnType Stella.Ast.AbsSyntax.BNFC'NoPosition) }
  | '->' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.SomeReturnType (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ThrowType :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.ThrowType) }
ThrowType
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, Stella.Ast.AbsSyntax.NoThrowType Stella.Ast.AbsSyntax.BNFC'NoPosition) }
  | 'throws' ListType9 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.SomeThrowType (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Type9 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Type) }
Type9 : Type { (fst $1, (snd $1)) }

ListType9 :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Type]) }
ListType9
  : Type9 { (fst $1, (:[]) (snd $1)) }
  | Type9 ',' ListType9 { (fst $1, (:) (snd $1) (snd $3)) }

MatchCase :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.MatchCase) }
MatchCase
  : Pattern '=>' Expr { (fst $1, Stella.Ast.AbsSyntax.AMatchCase (fst $1) (snd $1) (snd $3)) }

ListMatchCase :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.MatchCase]) }
ListMatchCase
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | MatchCase { (fst $1, (:[]) (snd $1)) }
  | MatchCase '|' ListMatchCase { (fst $1, (:) (snd $1) (snd $3)) }

OptionalTyping :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.OptionalTyping) }
OptionalTyping
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, Stella.Ast.AbsSyntax.NoTyping Stella.Ast.AbsSyntax.BNFC'NoPosition) }
  | ':' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.SomeTyping (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

PatternData :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.PatternData) }
PatternData
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, Stella.Ast.AbsSyntax.NoPatternData Stella.Ast.AbsSyntax.BNFC'NoPosition) }
  | '=' Pattern { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.SomePatternData (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ExprData :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.ExprData) }
ExprData
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, Stella.Ast.AbsSyntax.NoExprData Stella.Ast.AbsSyntax.BNFC'NoPosition) }
  | '=' Expr { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.SomeExprData (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Pattern :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Pattern) }
Pattern
  : Pattern 'as' Type { (fst $1, Stella.Ast.AbsSyntax.PatternAsc (fst $1) (snd $1) (snd $3)) }
  | '<|' StellaIdent PatternData '|>' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternVariant (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | 'inl' '(' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternInl (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'inr' '(' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternInr (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | '{' ListPattern '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternTuple (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '{' ListLabelledPattern '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternRecord (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '[' ListPattern ']' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternList (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'cons' '(' Pattern ',' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternCons (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | '(' Pattern ',' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.patternCons (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'false' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternFalse (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'true' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternTrue (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'unit' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternUnit (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | Integer { (fst $1, Stella.Ast.AbsSyntax.PatternInt (fst $1) (snd $1)) }
  | 'succ' '(' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.PatternSucc (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | StellaIdent { (fst $1, Stella.Ast.AbsSyntax.PatternVar (fst $1) (snd $1)) }
  | '(' Pattern ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListPattern :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Pattern]) }
ListPattern
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Pattern { (fst $1, (:[]) (snd $1)) }
  | Pattern ',' ListPattern { (fst $1, (:) (snd $1) (snd $3)) }

LabelledPattern :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.LabelledPattern) }
LabelledPattern
  : StellaIdent '=' Pattern { (fst $1, Stella.Ast.AbsSyntax.ALabelledPattern (fst $1) (snd $1) (snd $3)) }

ListLabelledPattern :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.LabelledPattern]) }
ListLabelledPattern
  : LabelledPattern { (fst $1, (:[]) (snd $1)) }
  | LabelledPattern ',' ListLabelledPattern { (fst $1, (:) (snd $1) (snd $3)) }

Binding :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Binding) }
Binding
  : StellaIdent '=' Expr { (fst $1, Stella.Ast.AbsSyntax.ABinding (fst $1) (snd $1) (snd $3)) }

ListBinding :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Binding]) }
ListBinding
  : Binding { (fst $1, (:[]) (snd $1)) }
  | Binding ',' ListBinding { (fst $1, (:) (snd $1) (snd $3)) }

Expr :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr
  : Expr1 ';' Expr { (fst $1, Stella.Ast.AbsSyntax.Sequence (fst $1) (snd $1) (snd $3)) }
  | Expr1 ';' { (fst $1, (snd $1)) }
  | 'let' ListPatternBinding 'in' Expr { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Let (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'letrec' ListPatternBinding 'in' Expr { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.LetRec (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'generic' '[' ListStellaIdent ']' Expr { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeAbstraction (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | Expr1 { (fst $1, (snd $1)) }

ListExpr :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Expr]) }
ListExpr
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Expr { (fst $1, (:[]) (snd $1)) }
  | Expr ',' ListExpr { (fst $1, (:) (snd $1) (snd $3)) }

Expr1 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr1
  : Expr2 ':=' Expr1 { (fst $1, Stella.Ast.AbsSyntax.Assign (fst $1) (snd $1) (snd $3)) }
  | 'if' Expr1 'then' Expr1 'else' Expr1 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.If (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | Expr2 { (fst $1, (snd $1)) }

PatternBinding :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.PatternBinding) }
PatternBinding
  : Pattern '=' Expr { (fst $1, Stella.Ast.AbsSyntax.APatternBinding (fst $1) (snd $1) (snd $3)) }

ListPatternBinding :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.PatternBinding]) }
ListPatternBinding
  : PatternBinding { (fst $1, (:[]) (snd $1)) }
  | PatternBinding ',' ListPatternBinding { (fst $1, (:) (snd $1) (snd $3)) }

Expr2 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr2
  : Expr3 '<' Expr3 { (fst $1, Stella.Ast.AbsSyntax.LessThan (fst $1) (snd $1) (snd $3)) }
  | Expr3 '<=' Expr3 { (fst $1, Stella.Ast.AbsSyntax.LessThanOrEqual (fst $1) (snd $1) (snd $3)) }
  | Expr3 '>' Expr3 { (fst $1, Stella.Ast.AbsSyntax.GreaterThan (fst $1) (snd $1) (snd $3)) }
  | Expr3 '>=' Expr3 { (fst $1, Stella.Ast.AbsSyntax.GreaterThanOrEqual (fst $1) (snd $1) (snd $3)) }
  | Expr3 '==' Expr3 { (fst $1, Stella.Ast.AbsSyntax.Equal (fst $1) (snd $1) (snd $3)) }
  | Expr3 '!=' Expr3 { (fst $1, Stella.Ast.AbsSyntax.NotEqual (fst $1) (snd $1) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

ListExpr2 :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Expr]) }
ListExpr2
  : Expr2 ';' { (fst $1, (:[]) (snd $1)) }
  | Expr2 ';' ListExpr2 { (fst $1, (:) (snd $1) (snd $3)) }

Expr3 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr3
  : Expr3 'as' Type2 { (fst $1, Stella.Ast.AbsSyntax.TypeAsc (fst $1) (snd $1) (snd $3)) }
  | Expr3 'cast' 'as' Type2 { (fst $1, Stella.Ast.AbsSyntax.TypeCast (fst $1) (snd $1) (snd $4)) }
  | 'fn' '(' ListParamDecl ')' '{' 'return' Expr '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Abstraction (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $7)) }
  | '<|' StellaIdent ExprData '|>' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Variant (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | 'match' Expr2 '{' ListMatchCase '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Match (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '[' ListExpr ']' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.List (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr3 '+' Expr4 { (fst $1, Stella.Ast.AbsSyntax.Add (fst $1) (snd $1) (snd $3)) }
  | Expr3 '-' Expr4 { (fst $1, Stella.Ast.AbsSyntax.Subtract (fst $1) (snd $1) (snd $3)) }
  | Expr3 'or' Expr4 { (fst $1, Stella.Ast.AbsSyntax.LogicOr (fst $1) (snd $1) (snd $3)) }
  | Expr4 { (fst $1, (snd $1)) }

Expr4 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr4
  : Expr4 '*' Expr5 { (fst $1, Stella.Ast.AbsSyntax.Multiply (fst $1) (snd $1) (snd $3)) }
  | Expr4 '/' Expr5 { (fst $1, Stella.Ast.AbsSyntax.Divide (fst $1) (snd $1) (snd $3)) }
  | Expr4 'and' Expr5 { (fst $1, Stella.Ast.AbsSyntax.LogicAnd (fst $1) (snd $1) (snd $3)) }
  | Expr5 { (fst $1, (snd $1)) }

Expr5 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr5
  : 'new' '(' Expr5 ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Ref (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | '*' Expr5 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Deref (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr6 { (fst $1, (snd $1)) }

Expr6 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr6
  : Expr6 '(' ListExpr ')' { (fst $1, Stella.Ast.AbsSyntax.Application (fst $1) (snd $1) (snd $3)) }
  | Expr6 '[' ListType ']' { (fst $1, Stella.Ast.AbsSyntax.TypeApplication (fst $1) (snd $1) (snd $3)) }
  | Expr6 '.' StellaIdent { (fst $1, Stella.Ast.AbsSyntax.DotRecord (fst $1) (snd $1) (snd $3)) }
  | Expr6 '.' Integer { (fst $1, Stella.Ast.AbsSyntax.DotTuple (fst $1) (snd $1) (snd $3)) }
  | '{' ListExpr '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Tuple (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '{' ListBinding '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Record (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'cons' '(' Expr ',' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.ConsList (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | 'List::head' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Head (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'List::isempty' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.IsEmpty (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'List::tail' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Tail (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'panic!' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Panic (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'throw' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Throw (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'try' '{' Expr '}' 'catch' '{' Pattern '=>' Expr '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TryCatch (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $7) (snd $9)) }
  | 'try' '{' Expr '}' 'with' '{' Expr '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TryWith (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $7)) }
  | 'inl' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Inl (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'inr' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Inr (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'succ' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Succ (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'not' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.LogicNot (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'Nat::pred' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Pred (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'Nat::iszero' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.IsZero (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'fix' '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Fix (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | 'Nat::rec' '(' Expr ',' Expr ',' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.NatRec (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $7)) }
  | 'fold' '[' Type ']' Expr7 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Fold (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | 'unfold' '[' Type ']' Expr7 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.Unfold (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | Expr7 { (fst $1, (snd $1)) }

Expr7 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Expr) }
Expr7
  : 'true' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.ConstTrue (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'false' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.ConstFalse (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'unit' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.ConstUnit (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | Integer { (fst $1, Stella.Ast.AbsSyntax.ConstInt (fst $1) (snd $1)) }
  | MemoryAddress { (fst $1, Stella.Ast.AbsSyntax.ConstMemory (fst $1) (snd $1)) }
  | StellaIdent { (fst $1, Stella.Ast.AbsSyntax.Var (fst $1) (snd $1)) }
  | '(' Expr ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

Type :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Type) }
Type
  : 'fn' '(' ListType ')' '->' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeFun (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $6)) }
  | 'forall' ListStellaIdent '.' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeForAll (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'µ' StellaIdent '.' Type { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeRec (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Type1 { (fst $1, (snd $1)) }

Type1 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Type) }
Type1
  : Type2 '+' Type2 { (fst $1, Stella.Ast.AbsSyntax.TypeSum (fst $1) (snd $1) (snd $3)) }
  | Type2 { (fst $1, (snd $1)) }

Type2 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Type) }
Type2
  : '{' ListType '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeTuple (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '{' ListRecordFieldType '}' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeRecord (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '<|' ListVariantFieldType '|>' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeVariant (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '[' Type ']' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeList (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Type3 { (fst $1, (snd $1)) }

Type3 :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Type) }
Type3
  : 'Bool' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeBool (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'Nat' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeNat (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'Unit' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeUnit (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'Top' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeTop (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | 'Bot' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeBottom (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1))) }
  | '&' Type2 { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), Stella.Ast.AbsSyntax.TypeRef (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | StellaIdent { (fst $1, Stella.Ast.AbsSyntax.TypeVar (fst $1) (snd $1)) }
  | '(' Type ')' { (uncurry Stella.Ast.AbsSyntax.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListType :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.Type]) }
ListType
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | Type { (fst $1, (:[]) (snd $1)) }
  | Type ',' ListType { (fst $1, (:) (snd $1) (snd $3)) }

VariantFieldType :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.VariantFieldType) }
VariantFieldType
  : StellaIdent OptionalTyping { (fst $1, Stella.Ast.AbsSyntax.AVariantFieldType (fst $1) (snd $1) (snd $2)) }

ListVariantFieldType :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.VariantFieldType]) }
ListVariantFieldType
  : {- empty -} { (Stella.Ast.AbsSyntax.BNFC'NoPosition, []) }
  | VariantFieldType { (fst $1, (:[]) (snd $1)) }
  | VariantFieldType ',' ListVariantFieldType { (fst $1, (:) (snd $1) (snd $3)) }

RecordFieldType :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.RecordFieldType) }
RecordFieldType
  : StellaIdent ':' Type { (fst $1, Stella.Ast.AbsSyntax.ARecordFieldType (fst $1) (snd $1) (snd $3)) }

ListRecordFieldType :: { (Stella.Ast.AbsSyntax.BNFC'Position, [Stella.Ast.AbsSyntax.RecordFieldType]) }
ListRecordFieldType
  : RecordFieldType { (fst $1, (:[]) (snd $1)) }
  | RecordFieldType ',' ListRecordFieldType { (fst $1, (:) (snd $1) (snd $3)) }

Typing :: { (Stella.Ast.AbsSyntax.BNFC'Position, Stella.Ast.AbsSyntax.Typing) }
Typing
  : Expr ':' Type { (fst $1, Stella.Ast.AbsSyntax.ATyping (fst $1) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Stella.Ast.AbsSyntax.Program
pProgram = fmap snd . pProgram_internal

pListStellaIdent :: [Token] -> Err [Stella.Ast.AbsSyntax.StellaIdent]
pListStellaIdent = fmap snd . pListStellaIdent_internal

pLanguageDecl :: [Token] -> Err Stella.Ast.AbsSyntax.LanguageDecl
pLanguageDecl = fmap snd . pLanguageDecl_internal

pExtension :: [Token] -> Err Stella.Ast.AbsSyntax.Extension
pExtension = fmap snd . pExtension_internal

pListExtensionName :: [Token] -> Err [Stella.Ast.AbsSyntax.ExtensionName]
pListExtensionName = fmap snd . pListExtensionName_internal

pListExtension :: [Token] -> Err [Stella.Ast.AbsSyntax.Extension]
pListExtension = fmap snd . pListExtension_internal

pDecl :: [Token] -> Err Stella.Ast.AbsSyntax.Decl
pDecl = fmap snd . pDecl_internal

pListDecl :: [Token] -> Err [Stella.Ast.AbsSyntax.Decl]
pListDecl = fmap snd . pListDecl_internal

pLocalDecl :: [Token] -> Err Stella.Ast.AbsSyntax.LocalDecl
pLocalDecl = fmap snd . pLocalDecl_internal

pListLocalDecl :: [Token] -> Err [Stella.Ast.AbsSyntax.LocalDecl]
pListLocalDecl = fmap snd . pListLocalDecl_internal

pAnnotation :: [Token] -> Err Stella.Ast.AbsSyntax.Annotation
pAnnotation = fmap snd . pAnnotation_internal

pListAnnotation :: [Token] -> Err [Stella.Ast.AbsSyntax.Annotation]
pListAnnotation = fmap snd . pListAnnotation_internal

pParamDecl :: [Token] -> Err Stella.Ast.AbsSyntax.ParamDecl
pParamDecl = fmap snd . pParamDecl_internal

pListParamDecl :: [Token] -> Err [Stella.Ast.AbsSyntax.ParamDecl]
pListParamDecl = fmap snd . pListParamDecl_internal

pReturnType :: [Token] -> Err Stella.Ast.AbsSyntax.ReturnType
pReturnType = fmap snd . pReturnType_internal

pThrowType :: [Token] -> Err Stella.Ast.AbsSyntax.ThrowType
pThrowType = fmap snd . pThrowType_internal

pType9 :: [Token] -> Err Stella.Ast.AbsSyntax.Type
pType9 = fmap snd . pType9_internal

pListType9 :: [Token] -> Err [Stella.Ast.AbsSyntax.Type]
pListType9 = fmap snd . pListType9_internal

pMatchCase :: [Token] -> Err Stella.Ast.AbsSyntax.MatchCase
pMatchCase = fmap snd . pMatchCase_internal

pListMatchCase :: [Token] -> Err [Stella.Ast.AbsSyntax.MatchCase]
pListMatchCase = fmap snd . pListMatchCase_internal

pOptionalTyping :: [Token] -> Err Stella.Ast.AbsSyntax.OptionalTyping
pOptionalTyping = fmap snd . pOptionalTyping_internal

pPatternData :: [Token] -> Err Stella.Ast.AbsSyntax.PatternData
pPatternData = fmap snd . pPatternData_internal

pExprData :: [Token] -> Err Stella.Ast.AbsSyntax.ExprData
pExprData = fmap snd . pExprData_internal

pPattern :: [Token] -> Err Stella.Ast.AbsSyntax.Pattern
pPattern = fmap snd . pPattern_internal

pListPattern :: [Token] -> Err [Stella.Ast.AbsSyntax.Pattern]
pListPattern = fmap snd . pListPattern_internal

pLabelledPattern :: [Token] -> Err Stella.Ast.AbsSyntax.LabelledPattern
pLabelledPattern = fmap snd . pLabelledPattern_internal

pListLabelledPattern :: [Token] -> Err [Stella.Ast.AbsSyntax.LabelledPattern]
pListLabelledPattern = fmap snd . pListLabelledPattern_internal

pBinding :: [Token] -> Err Stella.Ast.AbsSyntax.Binding
pBinding = fmap snd . pBinding_internal

pListBinding :: [Token] -> Err [Stella.Ast.AbsSyntax.Binding]
pListBinding = fmap snd . pListBinding_internal

pExpr :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr = fmap snd . pExpr_internal

pListExpr :: [Token] -> Err [Stella.Ast.AbsSyntax.Expr]
pListExpr = fmap snd . pListExpr_internal

pExpr1 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr1 = fmap snd . pExpr1_internal

pPatternBinding :: [Token] -> Err Stella.Ast.AbsSyntax.PatternBinding
pPatternBinding = fmap snd . pPatternBinding_internal

pListPatternBinding :: [Token] -> Err [Stella.Ast.AbsSyntax.PatternBinding]
pListPatternBinding = fmap snd . pListPatternBinding_internal

pExpr2 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr2 = fmap snd . pExpr2_internal

pListExpr2 :: [Token] -> Err [Stella.Ast.AbsSyntax.Expr]
pListExpr2 = fmap snd . pListExpr2_internal

pExpr3 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr3 = fmap snd . pExpr3_internal

pExpr4 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr4 = fmap snd . pExpr4_internal

pExpr5 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr5 = fmap snd . pExpr5_internal

pExpr6 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr6 = fmap snd . pExpr6_internal

pExpr7 :: [Token] -> Err Stella.Ast.AbsSyntax.Expr
pExpr7 = fmap snd . pExpr7_internal

pType :: [Token] -> Err Stella.Ast.AbsSyntax.Type
pType = fmap snd . pType_internal

pType1 :: [Token] -> Err Stella.Ast.AbsSyntax.Type
pType1 = fmap snd . pType1_internal

pType2 :: [Token] -> Err Stella.Ast.AbsSyntax.Type
pType2 = fmap snd . pType2_internal

pType3 :: [Token] -> Err Stella.Ast.AbsSyntax.Type
pType3 = fmap snd . pType3_internal

pListType :: [Token] -> Err [Stella.Ast.AbsSyntax.Type]
pListType = fmap snd . pListType_internal

pVariantFieldType :: [Token] -> Err Stella.Ast.AbsSyntax.VariantFieldType
pVariantFieldType = fmap snd . pVariantFieldType_internal

pListVariantFieldType :: [Token] -> Err [Stella.Ast.AbsSyntax.VariantFieldType]
pListVariantFieldType = fmap snd . pListVariantFieldType_internal

pRecordFieldType :: [Token] -> Err Stella.Ast.AbsSyntax.RecordFieldType
pRecordFieldType = fmap snd . pRecordFieldType_internal

pListRecordFieldType :: [Token] -> Err [Stella.Ast.AbsSyntax.RecordFieldType]
pListRecordFieldType = fmap snd . pListRecordFieldType_internal

pTyping :: [Token] -> Err Stella.Ast.AbsSyntax.Typing
pTyping = fmap snd . pTyping_internal
}

